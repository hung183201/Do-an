//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IHotelDetailsClient {
    search(idhotel: number | undefined): Observable<ApiResultOfIListOfHotelDetailDto>;
}

@Injectable({
    providedIn: 'root'
})
export class HotelDetailsClient implements IHotelDetailsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    search(idhotel: number | undefined): Observable<ApiResultOfIListOfHotelDetailDto> {
        let url_ = this.baseUrl + "/api/HotelDetails/Search?";
        if (idhotel === null)
            throw new Error("The parameter 'idhotel' cannot be null.");
        else if (idhotel !== undefined)
            url_ += "Idhotel=" + encodeURIComponent("" + idhotel) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResultOfIListOfHotelDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResultOfIListOfHotelDetailDto>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ApiResultOfIListOfHotelDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfIListOfHotelDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfIListOfHotelDetailDto>(null as any);
    }
}

export interface IHotelManageClient {
    add(command: HotelViewModel): Observable<ApiResultOfString>;
    edit(command: HotelViewModel): Observable<ApiResultOfString>;
    delete(id: number | undefined): Observable<ApiResultOfBoolean>;
    getById(id: number | undefined): Observable<ApiResultOfHotel>;
    getAll(): Observable<ApiResultOfIListOfHotel>;
    search(request: HotelRequest): Observable<ApiResultOfPagedListOfHotel>;
}

@Injectable({
    providedIn: 'root'
})
export class HotelManageClient implements IHotelManageClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    add(command: HotelViewModel): Observable<ApiResultOfString> {
        let url_ = this.baseUrl + "/api/HotelManage/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResultOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResultOfString>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<ApiResultOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResultOfString.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfString>(null as any);
    }

    edit(command: HotelViewModel): Observable<ApiResultOfString> {
        let url_ = this.baseUrl + "/api/HotelManage/Edit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResultOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResultOfString>;
        }));
    }

    protected processEdit(response: HttpResponseBase): Observable<ApiResultOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResultOfString.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfString>(null as any);
    }

    delete(id: number | undefined): Observable<ApiResultOfBoolean> {
        let url_ = this.baseUrl + "/api/HotelManage/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResultOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ApiResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResultOfString.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfBoolean>(null as any);
    }

    getById(id: number | undefined): Observable<ApiResultOfHotel> {
        let url_ = this.baseUrl + "/api/HotelManage/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResultOfHotel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResultOfHotel>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ApiResultOfHotel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfHotel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResultOfString.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfHotel>(null as any);
    }

    getAll(): Observable<ApiResultOfIListOfHotel> {
        let url_ = this.baseUrl + "/api/HotelManage/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResultOfIListOfHotel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResultOfIListOfHotel>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ApiResultOfIListOfHotel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfIListOfHotel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfIListOfHotel>(null as any);
    }

    search(request: HotelRequest): Observable<ApiResultOfPagedListOfHotel> {
        let url_ = this.baseUrl + "/api/HotelManage/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResultOfPagedListOfHotel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResultOfPagedListOfHotel>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ApiResultOfPagedListOfHotel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfPagedListOfHotel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfPagedListOfHotel>(null as any);
    }
}

export interface IHotelUtilityGroupClient {
    searchUtilityByGroup(hotelId: number | undefined, utilityId: number | undefined, isInGroup: number | undefined, filter: string | null | undefined): Observable<FileResponse>;
    insertUtilityIntoGroup(hotelId: number, utilityIds: number[]): Observable<void>;
    deleteUtilityFromGroup(hotelId: number, utility: number[]): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class HotelUtilityGroupClient implements IHotelUtilityGroupClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    searchUtilityByGroup(hotelId: number | undefined, utilityId: number | undefined, isInGroup: number | undefined, filter: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/HotelUtilityGroup/SearchUtilityByGroup?";
        if (hotelId === null)
            throw new Error("The parameter 'hotelId' cannot be null.");
        else if (hotelId !== undefined)
            url_ += "hotelId=" + encodeURIComponent("" + hotelId) + "&";
        if (utilityId === null)
            throw new Error("The parameter 'utilityId' cannot be null.");
        else if (utilityId !== undefined)
            url_ += "utilityId=" + encodeURIComponent("" + utilityId) + "&";
        if (isInGroup === null)
            throw new Error("The parameter 'isInGroup' cannot be null.");
        else if (isInGroup !== undefined)
            url_ += "isInGroup=" + encodeURIComponent("" + isInGroup) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchUtilityByGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchUtilityByGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSearchUtilityByGroup(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    insertUtilityIntoGroup(hotelId: number, utilityIds: number[]): Observable<void> {
        let url_ = this.baseUrl + "/api/HotelUtilityGroup/InsertUtilityIntoGroup/{hotelId}";
        if (hotelId === undefined || hotelId === null)
            throw new Error("The parameter 'hotelId' must be defined.");
        url_ = url_.replace("{hotelId}", encodeURIComponent("" + hotelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(utilityIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertUtilityIntoGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertUtilityIntoGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInsertUtilityIntoGroup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    deleteUtilityFromGroup(hotelId: number, utility: number[]): Observable<void> {
        let url_ = this.baseUrl + "/api/HotelUtilityGroup/DeleteUtilityFromGroup/{hotelId}";
        if (hotelId === undefined || hotelId === null)
            throw new Error("The parameter 'hotelId' must be defined.");
        url_ = url_.replace("{hotelId}", encodeURIComponent("" + hotelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(utility);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUtilityFromGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUtilityFromGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUtilityFromGroup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export interface IRoomTypeClient {
    add(command: RoomTypeViewModel): Observable<ApiResultOfString>;
    edit(command: RoomTypeViewModel): Observable<ApiResultOfString>;
    delete(id: number | undefined): Observable<ApiResultOfBoolean>;
    search(request: RoomtypeRequest): Observable<ApiResultOfPagedListOfRoomType>;
    getById(id: number | undefined): Observable<ApiResultOfRoomType>;
}

@Injectable({
    providedIn: 'root'
})
export class RoomTypeClient implements IRoomTypeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    add(command: RoomTypeViewModel): Observable<ApiResultOfString> {
        let url_ = this.baseUrl + "/api/RoomType/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResultOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResultOfString>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<ApiResultOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResultOfString.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfString>(null as any);
    }

    edit(command: RoomTypeViewModel): Observable<ApiResultOfString> {
        let url_ = this.baseUrl + "/api/RoomType/Edit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResultOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResultOfString>;
        }));
    }

    protected processEdit(response: HttpResponseBase): Observable<ApiResultOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResultOfString.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfString>(null as any);
    }

    delete(id: number | undefined): Observable<ApiResultOfBoolean> {
        let url_ = this.baseUrl + "/api/RoomType/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResultOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ApiResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResultOfString.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfBoolean>(null as any);
    }

    search(request: RoomtypeRequest): Observable<ApiResultOfPagedListOfRoomType> {
        let url_ = this.baseUrl + "/api/RoomType/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResultOfPagedListOfRoomType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResultOfPagedListOfRoomType>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ApiResultOfPagedListOfRoomType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfPagedListOfRoomType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfPagedListOfRoomType>(null as any);
    }

    getById(id: number | undefined): Observable<ApiResultOfRoomType> {
        let url_ = this.baseUrl + "/api/RoomType/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResultOfRoomType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResultOfRoomType>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ApiResultOfRoomType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfRoomType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResultOfString.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfRoomType>(null as any);
    }
}

export interface IUtilityManageClient {
    add(command: UtilityViewModel): Observable<ApiResultOfString>;
    edit(command: UtilityViewModel): Observable<ApiResultOfString>;
    delete(id: number | undefined): Observable<ApiResultOfBoolean>;
    search(request: UtilityRequest): Observable<ApiResultOfPagedListOfUtility>;
    getById(id: number | undefined): Observable<ApiResultOfUtility>;
}

@Injectable({
    providedIn: 'root'
})
export class UtilityManageClient implements IUtilityManageClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    add(command: UtilityViewModel): Observable<ApiResultOfString> {
        let url_ = this.baseUrl + "/api/UtilityManage/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResultOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResultOfString>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<ApiResultOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResultOfString.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfString>(null as any);
    }

    edit(command: UtilityViewModel): Observable<ApiResultOfString> {
        let url_ = this.baseUrl + "/api/UtilityManage/Edit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResultOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResultOfString>;
        }));
    }

    protected processEdit(response: HttpResponseBase): Observable<ApiResultOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResultOfString.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfString>(null as any);
    }

    delete(id: number | undefined): Observable<ApiResultOfBoolean> {
        let url_ = this.baseUrl + "/api/UtilityManage/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResultOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ApiResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResultOfString.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfBoolean>(null as any);
    }

    search(request: UtilityRequest): Observable<ApiResultOfPagedListOfUtility> {
        let url_ = this.baseUrl + "/api/UtilityManage/Search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResultOfPagedListOfUtility>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResultOfPagedListOfUtility>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ApiResultOfPagedListOfUtility> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfPagedListOfUtility.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfPagedListOfUtility>(null as any);
    }

    getById(id: number | undefined): Observable<ApiResultOfUtility> {
        let url_ = this.baseUrl + "/api/UtilityManage/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApiResultOfUtility>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApiResultOfUtility>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ApiResultOfUtility> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiResultOfUtility.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ApiResultOfString.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApiResultOfUtility>(null as any);
    }
}

export class ApiResultOfIListOfHotelDetailDto implements IApiResultOfIListOfHotelDetailDto {
    isError?: boolean;
    message?: string | undefined;
    data?: HotelDetailDto[] | undefined;
    code?: ApiCode;
    errors?: ValidationError[] | undefined;

    constructor(data?: IApiResultOfIListOfHotelDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(HotelDetailDto.fromJS(item));
            }
            this.code = _data["code"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ValidationError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiResultOfIListOfHotelDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfIListOfHotelDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["code"] = this.code;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApiResultOfIListOfHotelDetailDto {
    isError?: boolean;
    message?: string | undefined;
    data?: HotelDetailDto[] | undefined;
    code?: ApiCode;
    errors?: ValidationError[] | undefined;
}

export class HotelDetailDto implements IHotelDetailDto {
    nameHotel?: string | undefined;
    address?: string | undefined;
    note?: string | undefined;
    nameUtility?: string[] | undefined;

    constructor(data?: IHotelDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nameHotel = _data["nameHotel"];
            this.address = _data["address"];
            this.note = _data["note"];
            if (Array.isArray(_data["nameUtility"])) {
                this.nameUtility = [] as any;
                for (let item of _data["nameUtility"])
                    this.nameUtility!.push(item);
            }
        }
    }

    static fromJS(data: any): HotelDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new HotelDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameHotel"] = this.nameHotel;
        data["address"] = this.address;
        data["note"] = this.note;
        if (Array.isArray(this.nameUtility)) {
            data["nameUtility"] = [];
            for (let item of this.nameUtility)
                data["nameUtility"].push(item);
        }
        return data;
    }
}

export interface IHotelDetailDto {
    nameHotel?: string | undefined;
    address?: string | undefined;
    note?: string | undefined;
    nameUtility?: string[] | undefined;
}

export enum ApiCode {
    Success = 0,
    GeneralError = 100,
    ExistingData = 102,
    InvalidArgument = 105,
    BusinessError = 400,
    UnAuthorizedAccess = 401,
    NotFoundError = 404,
    InternalError = 500,
    ValidationError = 600,
    BuocXuLyNotExistOrProcessed = 801,
}

export class ValidationError implements IValidationError {
    field?: string | undefined;
    message?: string | undefined;

    constructor(data?: IValidationError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ValidationError {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["message"] = this.message;
        return data;
    }
}

export interface IValidationError {
    field?: string | undefined;
    message?: string | undefined;
}

export class ApiResultOfString implements IApiResultOfString {
    isError?: boolean;
    message?: string | undefined;
    data?: string | undefined;
    code?: ApiCode;
    errors?: ValidationError[] | undefined;

    constructor(data?: IApiResultOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            this.message = _data["message"];
            this.data = _data["data"];
            this.code = _data["code"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ValidationError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiResultOfString {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        data["message"] = this.message;
        data["data"] = this.data;
        data["code"] = this.code;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApiResultOfString {
    isError?: boolean;
    message?: string | undefined;
    data?: string | undefined;
    code?: ApiCode;
    errors?: ValidationError[] | undefined;
}

export class HotelViewModel implements IHotelViewModel {
    id?: number;
    nameHotel?: string | undefined;
    address?: string | undefined;
    note?: string | undefined;
    categoryHotel?: number | undefined;
    status?: TrangThai;

    constructor(data?: IHotelViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameHotel = _data["nameHotel"];
            this.address = _data["address"];
            this.note = _data["note"];
            this.categoryHotel = _data["categoryHotel"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): HotelViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new HotelViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameHotel"] = this.nameHotel;
        data["address"] = this.address;
        data["note"] = this.note;
        data["categoryHotel"] = this.categoryHotel;
        data["status"] = this.status;
        return data;
    }
}

export interface IHotelViewModel {
    id?: number;
    nameHotel?: string | undefined;
    address?: string | undefined;
    note?: string | undefined;
    categoryHotel?: number | undefined;
    status?: TrangThai;
}

export enum TrangThai {
    DeActive = 0,
    Active = 1,
}

export class ApiResultOfBoolean implements IApiResultOfBoolean {
    isError?: boolean;
    message?: string | undefined;
    data?: boolean;
    code?: ApiCode;
    errors?: ValidationError[] | undefined;

    constructor(data?: IApiResultOfBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            this.message = _data["message"];
            this.data = _data["data"];
            this.code = _data["code"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ValidationError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiResultOfBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        data["message"] = this.message;
        data["data"] = this.data;
        data["code"] = this.code;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApiResultOfBoolean {
    isError?: boolean;
    message?: string | undefined;
    data?: boolean;
    code?: ApiCode;
    errors?: ValidationError[] | undefined;
}

export class ApiResultOfHotel implements IApiResultOfHotel {
    isError?: boolean;
    message?: string | undefined;
    data?: Hotel | undefined;
    code?: ApiCode;
    errors?: ValidationError[] | undefined;

    constructor(data?: IApiResultOfHotel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            this.message = _data["message"];
            this.data = _data["data"] ? Hotel.fromJS(_data["data"]) : <any>undefined;
            this.code = _data["code"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ValidationError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiResultOfHotel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfHotel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["code"] = this.code;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApiResultOfHotel {
    isError?: boolean;
    message?: string | undefined;
    data?: Hotel | undefined;
    code?: ApiCode;
    errors?: ValidationError[] | undefined;
}

export class AuditableEntity implements IAuditableEntity {
    ngayTao?: Date | undefined;
    nguoiTao?: string | undefined;
    idNguoiTao?: string | undefined;
    ngayCapNhat?: Date | undefined;
    nguoiCapNhat?: string | undefined;
    idNguoiCapNhat?: string | undefined;

    constructor(data?: IAuditableEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ngayTao = _data["ngayTao"] ? new Date(_data["ngayTao"].toString()) : <any>undefined;
            this.nguoiTao = _data["nguoiTao"];
            this.idNguoiTao = _data["idNguoiTao"];
            this.ngayCapNhat = _data["ngayCapNhat"] ? new Date(_data["ngayCapNhat"].toString()) : <any>undefined;
            this.nguoiCapNhat = _data["nguoiCapNhat"];
            this.idNguoiCapNhat = _data["idNguoiCapNhat"];
        }
    }

    static fromJS(data: any): AuditableEntity {
        data = typeof data === 'object' ? data : {};
        let result = new AuditableEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ngayTao"] = this.ngayTao ? this.ngayTao.toISOString() : <any>undefined;
        data["nguoiTao"] = this.nguoiTao;
        data["idNguoiTao"] = this.idNguoiTao;
        data["ngayCapNhat"] = this.ngayCapNhat ? this.ngayCapNhat.toISOString() : <any>undefined;
        data["nguoiCapNhat"] = this.nguoiCapNhat;
        data["idNguoiCapNhat"] = this.idNguoiCapNhat;
        return data;
    }
}

export interface IAuditableEntity {
    ngayTao?: Date | undefined;
    nguoiTao?: string | undefined;
    idNguoiTao?: string | undefined;
    ngayCapNhat?: Date | undefined;
    nguoiCapNhat?: string | undefined;
    idNguoiCapNhat?: string | undefined;
}

export class BaseEntityOfInteger extends AuditableEntity implements IBaseEntityOfInteger {
    id?: number;

    constructor(data?: IBaseEntityOfInteger) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
        }
    }

    static override fromJS(data: any): BaseEntityOfInteger {
        data = typeof data === 'object' ? data : {};
        let result = new BaseEntityOfInteger();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        super.toJSON(data);
        return data;
    }
}

export interface IBaseEntityOfInteger extends IAuditableEntity {
    id?: number;
}

export class Hotel extends BaseEntityOfInteger implements IHotel {
    nameHotel?: string | undefined;
    address?: string | undefined;
    note?: string | undefined;
    categoryHotel?: LoaiKhachSan | undefined;
    status?: TrangThai;
    statusName?: string | undefined;
    imageHotelRooms?: ImageHotelRoom[] | undefined;
    roomTypes?: RoomType[] | undefined;
    hotelUtilities?: HotelUtility[] | undefined;

    constructor(data?: IHotel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.nameHotel = _data["nameHotel"];
            this.address = _data["address"];
            this.note = _data["note"];
            this.categoryHotel = _data["categoryHotel"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            if (Array.isArray(_data["imageHotelRooms"])) {
                this.imageHotelRooms = [] as any;
                for (let item of _data["imageHotelRooms"])
                    this.imageHotelRooms!.push(ImageHotelRoom.fromJS(item));
            }
            if (Array.isArray(_data["roomTypes"])) {
                this.roomTypes = [] as any;
                for (let item of _data["roomTypes"])
                    this.roomTypes!.push(RoomType.fromJS(item));
            }
            if (Array.isArray(_data["hotelUtilities"])) {
                this.hotelUtilities = [] as any;
                for (let item of _data["hotelUtilities"])
                    this.hotelUtilities!.push(HotelUtility.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Hotel {
        data = typeof data === 'object' ? data : {};
        let result = new Hotel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameHotel"] = this.nameHotel;
        data["address"] = this.address;
        data["note"] = this.note;
        data["categoryHotel"] = this.categoryHotel;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        if (Array.isArray(this.imageHotelRooms)) {
            data["imageHotelRooms"] = [];
            for (let item of this.imageHotelRooms)
                data["imageHotelRooms"].push(item.toJSON());
        }
        if (Array.isArray(this.roomTypes)) {
            data["roomTypes"] = [];
            for (let item of this.roomTypes)
                data["roomTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.hotelUtilities)) {
            data["hotelUtilities"] = [];
            for (let item of this.hotelUtilities)
                data["hotelUtilities"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHotel extends IBaseEntityOfInteger {
    nameHotel?: string | undefined;
    address?: string | undefined;
    note?: string | undefined;
    categoryHotel?: LoaiKhachSan | undefined;
    status?: TrangThai;
    statusName?: string | undefined;
    imageHotelRooms?: ImageHotelRoom[] | undefined;
    roomTypes?: RoomType[] | undefined;
    hotelUtilities?: HotelUtility[] | undefined;
}

export enum LoaiKhachSan {
    CanHo = 0,
    HotelRoom = 1,
}

export class ImageHotelRoom extends BaseEntityOfInteger implements IImageHotelRoom {
    idHotelOrRoom?: number | undefined;
    idImage?: number | undefined;
    idHotelOrRoomNavigation?: Hotel | undefined;
    idImageNavigation?: Image | undefined;
    roomType?: RoomType | undefined;

    constructor(data?: IImageHotelRoom) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.idHotelOrRoom = _data["idHotelOrRoom"];
            this.idImage = _data["idImage"];
            this.idHotelOrRoomNavigation = _data["idHotelOrRoomNavigation"] ? Hotel.fromJS(_data["idHotelOrRoomNavigation"]) : <any>undefined;
            this.idImageNavigation = _data["idImageNavigation"] ? Image.fromJS(_data["idImageNavigation"]) : <any>undefined;
            this.roomType = _data["roomType"] ? RoomType.fromJS(_data["roomType"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): ImageHotelRoom {
        data = typeof data === 'object' ? data : {};
        let result = new ImageHotelRoom();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idHotelOrRoom"] = this.idHotelOrRoom;
        data["idImage"] = this.idImage;
        data["idHotelOrRoomNavigation"] = this.idHotelOrRoomNavigation ? this.idHotelOrRoomNavigation.toJSON() : <any>undefined;
        data["idImageNavigation"] = this.idImageNavigation ? this.idImageNavigation.toJSON() : <any>undefined;
        data["roomType"] = this.roomType ? this.roomType.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IImageHotelRoom extends IBaseEntityOfInteger {
    idHotelOrRoom?: number | undefined;
    idImage?: number | undefined;
    idHotelOrRoomNavigation?: Hotel | undefined;
    idImageNavigation?: Image | undefined;
    roomType?: RoomType | undefined;
}

export class Image extends BaseEntityOfInteger implements IImage {
    imageName?: string | undefined;
    url?: string | undefined;
    status?: TrangThai;
    statusName?: string | undefined;
    imageHotelRooms?: ImageHotelRoom[] | undefined;

    constructor(data?: IImage) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.imageName = _data["imageName"];
            this.url = _data["url"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            if (Array.isArray(_data["imageHotelRooms"])) {
                this.imageHotelRooms = [] as any;
                for (let item of _data["imageHotelRooms"])
                    this.imageHotelRooms!.push(ImageHotelRoom.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Image {
        data = typeof data === 'object' ? data : {};
        let result = new Image();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageName"] = this.imageName;
        data["url"] = this.url;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        if (Array.isArray(this.imageHotelRooms)) {
            data["imageHotelRooms"] = [];
            for (let item of this.imageHotelRooms)
                data["imageHotelRooms"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IImage extends IBaseEntityOfInteger {
    imageName?: string | undefined;
    url?: string | undefined;
    status?: TrangThai;
    statusName?: string | undefined;
    imageHotelRooms?: ImageHotelRoom[] | undefined;
}

export class RoomType extends BaseEntityOfInteger implements IRoomType {
    nameRoomType?: string | undefined;
    price?: number | undefined;
    totalRoom?: number | undefined;
    size?: string | undefined;
    maxPeople?: number | undefined;
    totalBed?: number | undefined;
    extraBed?: string | undefined;
    idHotel?: number | undefined;
    status?: TrangThai;
    statusName?: string | undefined;
    idHotelNavigation?: Hotel | undefined;
    idRoomTypeNavigation?: ImageHotelRoom | undefined;
    roomBookings?: RoomBooking[] | undefined;
    roomUtilities?: RoomUtility[] | undefined;
    rooms?: Room[] | undefined;

    constructor(data?: IRoomType) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.nameRoomType = _data["nameRoomType"];
            this.price = _data["price"];
            this.totalRoom = _data["totalRoom"];
            this.size = _data["size"];
            this.maxPeople = _data["maxPeople"];
            this.totalBed = _data["totalBed"];
            this.extraBed = _data["extraBed"];
            this.idHotel = _data["idHotel"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.idHotelNavigation = _data["idHotelNavigation"] ? Hotel.fromJS(_data["idHotelNavigation"]) : <any>undefined;
            this.idRoomTypeNavigation = _data["idRoomTypeNavigation"] ? ImageHotelRoom.fromJS(_data["idRoomTypeNavigation"]) : <any>undefined;
            if (Array.isArray(_data["roomBookings"])) {
                this.roomBookings = [] as any;
                for (let item of _data["roomBookings"])
                    this.roomBookings!.push(RoomBooking.fromJS(item));
            }
            if (Array.isArray(_data["roomUtilities"])) {
                this.roomUtilities = [] as any;
                for (let item of _data["roomUtilities"])
                    this.roomUtilities!.push(RoomUtility.fromJS(item));
            }
            if (Array.isArray(_data["rooms"])) {
                this.rooms = [] as any;
                for (let item of _data["rooms"])
                    this.rooms!.push(Room.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): RoomType {
        data = typeof data === 'object' ? data : {};
        let result = new RoomType();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameRoomType"] = this.nameRoomType;
        data["price"] = this.price;
        data["totalRoom"] = this.totalRoom;
        data["size"] = this.size;
        data["maxPeople"] = this.maxPeople;
        data["totalBed"] = this.totalBed;
        data["extraBed"] = this.extraBed;
        data["idHotel"] = this.idHotel;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["idHotelNavigation"] = this.idHotelNavigation ? this.idHotelNavigation.toJSON() : <any>undefined;
        data["idRoomTypeNavigation"] = this.idRoomTypeNavigation ? this.idRoomTypeNavigation.toJSON() : <any>undefined;
        if (Array.isArray(this.roomBookings)) {
            data["roomBookings"] = [];
            for (let item of this.roomBookings)
                data["roomBookings"].push(item.toJSON());
        }
        if (Array.isArray(this.roomUtilities)) {
            data["roomUtilities"] = [];
            for (let item of this.roomUtilities)
                data["roomUtilities"].push(item.toJSON());
        }
        if (Array.isArray(this.rooms)) {
            data["rooms"] = [];
            for (let item of this.rooms)
                data["rooms"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IRoomType extends IBaseEntityOfInteger {
    nameRoomType?: string | undefined;
    price?: number | undefined;
    totalRoom?: number | undefined;
    size?: string | undefined;
    maxPeople?: number | undefined;
    totalBed?: number | undefined;
    extraBed?: string | undefined;
    idHotel?: number | undefined;
    status?: TrangThai;
    statusName?: string | undefined;
    idHotelNavigation?: Hotel | undefined;
    idRoomTypeNavigation?: ImageHotelRoom | undefined;
    roomBookings?: RoomBooking[] | undefined;
    roomUtilities?: RoomUtility[] | undefined;
    rooms?: Room[] | undefined;
}

export class RoomBooking extends BaseEntityOfInteger implements IRoomBooking {
    idRoomType?: number | undefined;
    idBooking?: number | undefined;
    price?: number | undefined;
    idBookingNavigation?: Booking | undefined;
    idRoomTypeNavigation?: RoomType | undefined;

    constructor(data?: IRoomBooking) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.idRoomType = _data["idRoomType"];
            this.idBooking = _data["idBooking"];
            this.price = _data["price"];
            this.idBookingNavigation = _data["idBookingNavigation"] ? Booking.fromJS(_data["idBookingNavigation"]) : <any>undefined;
            this.idRoomTypeNavigation = _data["idRoomTypeNavigation"] ? RoomType.fromJS(_data["idRoomTypeNavigation"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): RoomBooking {
        data = typeof data === 'object' ? data : {};
        let result = new RoomBooking();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idRoomType"] = this.idRoomType;
        data["idBooking"] = this.idBooking;
        data["price"] = this.price;
        data["idBookingNavigation"] = this.idBookingNavigation ? this.idBookingNavigation.toJSON() : <any>undefined;
        data["idRoomTypeNavigation"] = this.idRoomTypeNavigation ? this.idRoomTypeNavigation.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IRoomBooking extends IBaseEntityOfInteger {
    idRoomType?: number | undefined;
    idBooking?: number | undefined;
    price?: number | undefined;
    idBookingNavigation?: Booking | undefined;
    idRoomTypeNavigation?: RoomType | undefined;
}

export class Booking extends BaseEntityOfInteger implements IBooking {
    idUser?: number | undefined;
    userId?: string;
    checkIn?: Date | undefined;
    checkOut?: string | undefined;
    totalPrice?: number | undefined;
    note?: string | undefined;
    status?: TrangThai;
    statusName?: string | undefined;
    appUser?: AppUser | undefined;
    idUserNavigation?: UserClient | undefined;
    roomBookings?: RoomBooking[] | undefined;
    booKingServices?: BooKingServices[] | undefined;

    constructor(data?: IBooking) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.idUser = _data["idUser"];
            this.userId = _data["userId"];
            this.checkIn = _data["checkIn"] ? new Date(_data["checkIn"].toString()) : <any>undefined;
            this.checkOut = _data["checkOut"];
            this.totalPrice = _data["totalPrice"];
            this.note = _data["note"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.appUser = _data["appUser"] ? AppUser.fromJS(_data["appUser"]) : <any>undefined;
            this.idUserNavigation = _data["idUserNavigation"] ? UserClient.fromJS(_data["idUserNavigation"]) : <any>undefined;
            if (Array.isArray(_data["roomBookings"])) {
                this.roomBookings = [] as any;
                for (let item of _data["roomBookings"])
                    this.roomBookings!.push(RoomBooking.fromJS(item));
            }
            if (Array.isArray(_data["booKingServices"])) {
                this.booKingServices = [] as any;
                for (let item of _data["booKingServices"])
                    this.booKingServices!.push(BooKingServices.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Booking {
        data = typeof data === 'object' ? data : {};
        let result = new Booking();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idUser"] = this.idUser;
        data["userId"] = this.userId;
        data["checkIn"] = this.checkIn ? this.checkIn.toISOString() : <any>undefined;
        data["checkOut"] = this.checkOut;
        data["totalPrice"] = this.totalPrice;
        data["note"] = this.note;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["appUser"] = this.appUser ? this.appUser.toJSON() : <any>undefined;
        data["idUserNavigation"] = this.idUserNavigation ? this.idUserNavigation.toJSON() : <any>undefined;
        if (Array.isArray(this.roomBookings)) {
            data["roomBookings"] = [];
            for (let item of this.roomBookings)
                data["roomBookings"].push(item.toJSON());
        }
        if (Array.isArray(this.booKingServices)) {
            data["booKingServices"] = [];
            for (let item of this.booKingServices)
                data["booKingServices"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IBooking extends IBaseEntityOfInteger {
    idUser?: number | undefined;
    userId?: string;
    checkIn?: Date | undefined;
    checkOut?: string | undefined;
    totalPrice?: number | undefined;
    note?: string | undefined;
    status?: TrangThai;
    statusName?: string | undefined;
    appUser?: AppUser | undefined;
    idUserNavigation?: UserClient | undefined;
    roomBookings?: RoomBooking[] | undefined;
    booKingServices?: BooKingServices[] | undefined;
}

/** Represents a user in the identity system */
export class IdentityUserOfGuid implements IIdentityUserOfGuid {
    /** Gets or sets the primary key for this user. */
    id?: string;
    /** Gets or sets the user name for this user. */
    userName?: string | undefined;
    /** Gets or sets the normalized user name for this user. */
    normalizedUserName?: string | undefined;
    /** Gets or sets the email address for this user. */
    email?: string | undefined;
    /** Gets or sets the normalized email address for this user. */
    normalizedEmail?: string | undefined;
    /** Gets or sets a flag indicating if a user has confirmed their email address. */
    emailConfirmed?: boolean;
    /** Gets or sets a salted and hashed representation of the password for this user. */
    passwordHash?: string | undefined;
    /** A random value that must change whenever a users credentials change (password changed, login removed) */
    securityStamp?: string | undefined;
    /** A random value that must change whenever a user is persisted to the store */
    concurrencyStamp?: string | undefined;
    /** Gets or sets a telephone number for the user. */
    phoneNumber?: string | undefined;
    /** Gets or sets a flag indicating if a user has confirmed their telephone address. */
    phoneNumberConfirmed?: boolean;
    /** Gets or sets a flag indicating if two factor authentication is enabled for this user. */
    twoFactorEnabled?: boolean;
    /** Gets or sets the date and time, in UTC, when any user lockout ends. */
    lockoutEnd?: Date | undefined;
    /** Gets or sets a flag indicating if the user could be locked out. */
    lockoutEnabled?: boolean;
    /** Gets or sets the number of failed login attempts for the current user. */
    accessFailedCount?: number;

    constructor(data?: IIdentityUserOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
        }
    }

    static fromJS(data: any): IdentityUserOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data;
    }
}

/** Represents a user in the identity system */
export interface IIdentityUserOfGuid {
    /** Gets or sets the primary key for this user. */
    id?: string;
    /** Gets or sets the user name for this user. */
    userName?: string | undefined;
    /** Gets or sets the normalized user name for this user. */
    normalizedUserName?: string | undefined;
    /** Gets or sets the email address for this user. */
    email?: string | undefined;
    /** Gets or sets the normalized email address for this user. */
    normalizedEmail?: string | undefined;
    /** Gets or sets a flag indicating if a user has confirmed their email address. */
    emailConfirmed?: boolean;
    /** Gets or sets a salted and hashed representation of the password for this user. */
    passwordHash?: string | undefined;
    /** A random value that must change whenever a users credentials change (password changed, login removed) */
    securityStamp?: string | undefined;
    /** A random value that must change whenever a user is persisted to the store */
    concurrencyStamp?: string | undefined;
    /** Gets or sets a telephone number for the user. */
    phoneNumber?: string | undefined;
    /** Gets or sets a flag indicating if a user has confirmed their telephone address. */
    phoneNumberConfirmed?: boolean;
    /** Gets or sets a flag indicating if two factor authentication is enabled for this user. */
    twoFactorEnabled?: boolean;
    /** Gets or sets the date and time, in UTC, when any user lockout ends. */
    lockoutEnd?: Date | undefined;
    /** Gets or sets a flag indicating if the user could be locked out. */
    lockoutEnabled?: boolean;
    /** Gets or sets the number of failed login attempts for the current user. */
    accessFailedCount?: number;
}

export class AppUser extends IdentityUserOfGuid implements IAppUser {
    fullName?: string | undefined;
    dob?: Date;
    bookings?: Booking[] | undefined;

    constructor(data?: IAppUser) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fullName = _data["fullName"];
            this.dob = _data["dob"] ? new Date(_data["dob"].toString()) : <any>undefined;
            if (Array.isArray(_data["bookings"])) {
                this.bookings = [] as any;
                for (let item of _data["bookings"])
                    this.bookings!.push(Booking.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): AppUser {
        data = typeof data === 'object' ? data : {};
        let result = new AppUser();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        if (Array.isArray(this.bookings)) {
            data["bookings"] = [];
            for (let item of this.bookings)
                data["bookings"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAppUser extends IIdentityUserOfGuid {
    fullName?: string | undefined;
    dob?: Date;
    bookings?: Booking[] | undefined;
}

export class UserClient extends BaseEntityOfInteger implements IUserClient {
    nameClient?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    status?: TrangThai;
    statusName?: string | undefined;
    bookings?: Booking[] | undefined;

    constructor(data?: IUserClient) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.nameClient = _data["nameClient"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            if (Array.isArray(_data["bookings"])) {
                this.bookings = [] as any;
                for (let item of _data["bookings"])
                    this.bookings!.push(Booking.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): UserClient {
        data = typeof data === 'object' ? data : {};
        let result = new UserClient();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameClient"] = this.nameClient;
        data["password"] = this.password;
        data["email"] = this.email;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        if (Array.isArray(this.bookings)) {
            data["bookings"] = [];
            for (let item of this.bookings)
                data["bookings"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IUserClient extends IBaseEntityOfInteger {
    nameClient?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
    status?: TrangThai;
    statusName?: string | undefined;
    bookings?: Booking[] | undefined;
}

export class BooKingServices extends BaseEntityOfInteger implements IBooKingServices {
    idBooking?: number | undefined;
    idServices?: number | undefined;
    quantity?: number;
    idBookingNavigation?: Booking | undefined;
    idServicesNavigation?: Servicess | undefined;

    constructor(data?: IBooKingServices) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.idBooking = _data["idBooking"];
            this.idServices = _data["idServices"];
            this.quantity = _data["quantity"];
            this.idBookingNavigation = _data["idBookingNavigation"] ? Booking.fromJS(_data["idBookingNavigation"]) : <any>undefined;
            this.idServicesNavigation = _data["idServicesNavigation"] ? Servicess.fromJS(_data["idServicesNavigation"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): BooKingServices {
        data = typeof data === 'object' ? data : {};
        let result = new BooKingServices();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idBooking"] = this.idBooking;
        data["idServices"] = this.idServices;
        data["quantity"] = this.quantity;
        data["idBookingNavigation"] = this.idBookingNavigation ? this.idBookingNavigation.toJSON() : <any>undefined;
        data["idServicesNavigation"] = this.idServicesNavigation ? this.idServicesNavigation.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IBooKingServices extends IBaseEntityOfInteger {
    idBooking?: number | undefined;
    idServices?: number | undefined;
    quantity?: number;
    idBookingNavigation?: Booking | undefined;
    idServicesNavigation?: Servicess | undefined;
}

export class Servicess extends BaseEntityOfInteger implements IServicess {
    nameService?: string | undefined;
    price?: number;
    status?: TrangThai;
    statusName?: string | undefined;
    booKingServices?: BooKingServices[] | undefined;

    constructor(data?: IServicess) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.nameService = _data["nameService"];
            this.price = _data["price"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            if (Array.isArray(_data["booKingServices"])) {
                this.booKingServices = [] as any;
                for (let item of _data["booKingServices"])
                    this.booKingServices!.push(BooKingServices.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Servicess {
        data = typeof data === 'object' ? data : {};
        let result = new Servicess();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameService"] = this.nameService;
        data["price"] = this.price;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        if (Array.isArray(this.booKingServices)) {
            data["booKingServices"] = [];
            for (let item of this.booKingServices)
                data["booKingServices"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IServicess extends IBaseEntityOfInteger {
    nameService?: string | undefined;
    price?: number;
    status?: TrangThai;
    statusName?: string | undefined;
    booKingServices?: BooKingServices[] | undefined;
}

export class RoomUtility extends BaseEntityOfInteger implements IRoomUtility {
    idUtilities?: number | undefined;
    idRoomTypes?: number | undefined;
    idRoomTypesNavigation?: RoomType | undefined;
    idUtilitiesNavigation?: Utility | undefined;

    constructor(data?: IRoomUtility) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.idUtilities = _data["idUtilities"];
            this.idRoomTypes = _data["idRoomTypes"];
            this.idRoomTypesNavigation = _data["idRoomTypesNavigation"] ? RoomType.fromJS(_data["idRoomTypesNavigation"]) : <any>undefined;
            this.idUtilitiesNavigation = _data["idUtilitiesNavigation"] ? Utility.fromJS(_data["idUtilitiesNavigation"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): RoomUtility {
        data = typeof data === 'object' ? data : {};
        let result = new RoomUtility();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idUtilities"] = this.idUtilities;
        data["idRoomTypes"] = this.idRoomTypes;
        data["idRoomTypesNavigation"] = this.idRoomTypesNavigation ? this.idRoomTypesNavigation.toJSON() : <any>undefined;
        data["idUtilitiesNavigation"] = this.idUtilitiesNavigation ? this.idUtilitiesNavigation.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IRoomUtility extends IBaseEntityOfInteger {
    idUtilities?: number | undefined;
    idRoomTypes?: number | undefined;
    idRoomTypesNavigation?: RoomType | undefined;
    idUtilitiesNavigation?: Utility | undefined;
}

export class Utility extends BaseEntityOfInteger implements IUtility {
    nameUtilities?: string | undefined;
    icon?: string | undefined;
    utilitiesType?: number | undefined;
    status?: TrangThai;
    statusName?: string | undefined;
    roomUtilities?: RoomUtility[] | undefined;
    hotelUtilities?: HotelUtility[] | undefined;

    constructor(data?: IUtility) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.nameUtilities = _data["nameUtilities"];
            this.icon = _data["icon"];
            this.utilitiesType = _data["utilitiesType"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            if (Array.isArray(_data["roomUtilities"])) {
                this.roomUtilities = [] as any;
                for (let item of _data["roomUtilities"])
                    this.roomUtilities!.push(RoomUtility.fromJS(item));
            }
            if (Array.isArray(_data["hotelUtilities"])) {
                this.hotelUtilities = [] as any;
                for (let item of _data["hotelUtilities"])
                    this.hotelUtilities!.push(HotelUtility.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Utility {
        data = typeof data === 'object' ? data : {};
        let result = new Utility();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameUtilities"] = this.nameUtilities;
        data["icon"] = this.icon;
        data["utilitiesType"] = this.utilitiesType;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        if (Array.isArray(this.roomUtilities)) {
            data["roomUtilities"] = [];
            for (let item of this.roomUtilities)
                data["roomUtilities"].push(item.toJSON());
        }
        if (Array.isArray(this.hotelUtilities)) {
            data["hotelUtilities"] = [];
            for (let item of this.hotelUtilities)
                data["hotelUtilities"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IUtility extends IBaseEntityOfInteger {
    nameUtilities?: string | undefined;
    icon?: string | undefined;
    utilitiesType?: number | undefined;
    status?: TrangThai;
    statusName?: string | undefined;
    roomUtilities?: RoomUtility[] | undefined;
    hotelUtilities?: HotelUtility[] | undefined;
}

export class HotelUtility extends BaseEntityOfInteger implements IHotelUtility {
    idUtilities?: number;
    idHotels?: number;
    idHotelsNavigation?: Hotel | undefined;
    idUtilitiesNavigation?: Utility | undefined;

    constructor(data?: IHotelUtility) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.idUtilities = _data["idUtilities"];
            this.idHotels = _data["idHotels"];
            this.idHotelsNavigation = _data["idHotelsNavigation"] ? Hotel.fromJS(_data["idHotelsNavigation"]) : <any>undefined;
            this.idUtilitiesNavigation = _data["idUtilitiesNavigation"] ? Utility.fromJS(_data["idUtilitiesNavigation"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): HotelUtility {
        data = typeof data === 'object' ? data : {};
        let result = new HotelUtility();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idUtilities"] = this.idUtilities;
        data["idHotels"] = this.idHotels;
        data["idHotelsNavigation"] = this.idHotelsNavigation ? this.idHotelsNavigation.toJSON() : <any>undefined;
        data["idUtilitiesNavigation"] = this.idUtilitiesNavigation ? this.idUtilitiesNavigation.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IHotelUtility extends IBaseEntityOfInteger {
    idUtilities?: number;
    idHotels?: number;
    idHotelsNavigation?: Hotel | undefined;
    idUtilitiesNavigation?: Utility | undefined;
}

export class Room extends BaseEntityOfInteger implements IRoom {
    image?: string | undefined;
    idRoomType?: number | undefined;
    status?: TrangThai;
    tenTrangThai?: string | undefined;
    idRoomTypeNavigation?: RoomType | undefined;

    constructor(data?: IRoom) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.image = _data["image"];
            this.idRoomType = _data["idRoomType"];
            this.status = _data["status"];
            this.tenTrangThai = _data["tenTrangThai"];
            this.idRoomTypeNavigation = _data["idRoomTypeNavigation"] ? RoomType.fromJS(_data["idRoomTypeNavigation"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Room {
        data = typeof data === 'object' ? data : {};
        let result = new Room();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["image"] = this.image;
        data["idRoomType"] = this.idRoomType;
        data["status"] = this.status;
        data["tenTrangThai"] = this.tenTrangThai;
        data["idRoomTypeNavigation"] = this.idRoomTypeNavigation ? this.idRoomTypeNavigation.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IRoom extends IBaseEntityOfInteger {
    image?: string | undefined;
    idRoomType?: number | undefined;
    status?: TrangThai;
    tenTrangThai?: string | undefined;
    idRoomTypeNavigation?: RoomType | undefined;
}

export class ApiResultOfIListOfHotel implements IApiResultOfIListOfHotel {
    isError?: boolean;
    message?: string | undefined;
    data?: Hotel[] | undefined;
    code?: ApiCode;
    errors?: ValidationError[] | undefined;

    constructor(data?: IApiResultOfIListOfHotel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            this.message = _data["message"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Hotel.fromJS(item));
            }
            this.code = _data["code"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ValidationError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiResultOfIListOfHotel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfIListOfHotel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        data["message"] = this.message;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["code"] = this.code;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApiResultOfIListOfHotel {
    isError?: boolean;
    message?: string | undefined;
    data?: Hotel[] | undefined;
    code?: ApiCode;
    errors?: ValidationError[] | undefined;
}

export class ApiResultOfPagedListOfHotel implements IApiResultOfPagedListOfHotel {
    isError?: boolean;
    message?: string | undefined;
    data?: PagedListOfHotel | undefined;
    code?: ApiCode;
    errors?: ValidationError[] | undefined;

    constructor(data?: IApiResultOfPagedListOfHotel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            this.message = _data["message"];
            this.data = _data["data"] ? PagedListOfHotel.fromJS(_data["data"]) : <any>undefined;
            this.code = _data["code"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ValidationError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiResultOfPagedListOfHotel {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfPagedListOfHotel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["code"] = this.code;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApiResultOfPagedListOfHotel {
    isError?: boolean;
    message?: string | undefined;
    data?: PagedListOfHotel | undefined;
    code?: ApiCode;
    errors?: ValidationError[] | undefined;
}

export class PagedListOfHotel implements IPagedListOfHotel {
    pageIndex?: number;
    pageSize?: number;
    rowModify?: number;
    totalCount?: number;
    totalPages?: number;
    items?: Hotel[] | undefined;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedListOfHotel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.rowModify = _data["rowModify"];
            this.totalCount = _data["totalCount"];
            this.totalPages = _data["totalPages"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Hotel.fromJS(item));
            }
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedListOfHotel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListOfHotel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["rowModify"] = this.rowModify;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedListOfHotel {
    pageIndex?: number;
    pageSize?: number;
    rowModify?: number;
    totalCount?: number;
    totalPages?: number;
    items?: Hotel[] | undefined;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class PagingRequest implements IPagingRequest {
    fullTextSearch?: string | undefined;
    pageSize?: number;
    pageNumber?: number;
    totalCount?: number;
    rowModify?: number;

    constructor(data?: IPagingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullTextSearch = _data["fullTextSearch"];
            this.pageSize = _data["pageSize"];
            this.pageNumber = _data["pageNumber"];
            this.totalCount = _data["totalCount"];
            this.rowModify = _data["rowModify"];
        }
    }

    static fromJS(data: any): PagingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullTextSearch"] = this.fullTextSearch;
        data["pageSize"] = this.pageSize;
        data["pageNumber"] = this.pageNumber;
        data["totalCount"] = this.totalCount;
        data["rowModify"] = this.rowModify;
        return data;
    }
}

export interface IPagingRequest {
    fullTextSearch?: string | undefined;
    pageSize?: number;
    pageNumber?: number;
    totalCount?: number;
    rowModify?: number;
}

export class HotelRequest extends PagingRequest implements IHotelRequest {

    constructor(data?: IHotelRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): HotelRequest {
        data = typeof data === 'object' ? data : {};
        let result = new HotelRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IHotelRequest extends IPagingRequest {
}

export class RoomTypeViewModel implements IRoomTypeViewModel {
    id?: number;
    nameRoomType?: string | undefined;
    price?: number | undefined;
    totalRoom?: number | undefined;
    size?: string | undefined;
    maxPeople?: number | undefined;
    totalBed?: number | undefined;
    extraBed?: string | undefined;
    idHotel?: number | undefined;

    constructor(data?: IRoomTypeViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameRoomType = _data["nameRoomType"];
            this.price = _data["price"];
            this.totalRoom = _data["totalRoom"];
            this.size = _data["size"];
            this.maxPeople = _data["maxPeople"];
            this.totalBed = _data["totalBed"];
            this.extraBed = _data["extraBed"];
            this.idHotel = _data["idHotel"];
        }
    }

    static fromJS(data: any): RoomTypeViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new RoomTypeViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameRoomType"] = this.nameRoomType;
        data["price"] = this.price;
        data["totalRoom"] = this.totalRoom;
        data["size"] = this.size;
        data["maxPeople"] = this.maxPeople;
        data["totalBed"] = this.totalBed;
        data["extraBed"] = this.extraBed;
        data["idHotel"] = this.idHotel;
        return data;
    }
}

export interface IRoomTypeViewModel {
    id?: number;
    nameRoomType?: string | undefined;
    price?: number | undefined;
    totalRoom?: number | undefined;
    size?: string | undefined;
    maxPeople?: number | undefined;
    totalBed?: number | undefined;
    extraBed?: string | undefined;
    idHotel?: number | undefined;
}

export class ApiResultOfPagedListOfRoomType implements IApiResultOfPagedListOfRoomType {
    isError?: boolean;
    message?: string | undefined;
    data?: PagedListOfRoomType | undefined;
    code?: ApiCode;
    errors?: ValidationError[] | undefined;

    constructor(data?: IApiResultOfPagedListOfRoomType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            this.message = _data["message"];
            this.data = _data["data"] ? PagedListOfRoomType.fromJS(_data["data"]) : <any>undefined;
            this.code = _data["code"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ValidationError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiResultOfPagedListOfRoomType {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfPagedListOfRoomType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["code"] = this.code;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApiResultOfPagedListOfRoomType {
    isError?: boolean;
    message?: string | undefined;
    data?: PagedListOfRoomType | undefined;
    code?: ApiCode;
    errors?: ValidationError[] | undefined;
}

export class PagedListOfRoomType implements IPagedListOfRoomType {
    pageIndex?: number;
    pageSize?: number;
    rowModify?: number;
    totalCount?: number;
    totalPages?: number;
    items?: RoomType[] | undefined;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedListOfRoomType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.rowModify = _data["rowModify"];
            this.totalCount = _data["totalCount"];
            this.totalPages = _data["totalPages"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoomType.fromJS(item));
            }
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedListOfRoomType {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListOfRoomType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["rowModify"] = this.rowModify;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedListOfRoomType {
    pageIndex?: number;
    pageSize?: number;
    rowModify?: number;
    totalCount?: number;
    totalPages?: number;
    items?: RoomType[] | undefined;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class RoomtypeRequest extends PagingRequest implements IRoomtypeRequest {

    constructor(data?: IRoomtypeRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): RoomtypeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RoomtypeRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IRoomtypeRequest extends IPagingRequest {
}

export class ApiResultOfRoomType implements IApiResultOfRoomType {
    isError?: boolean;
    message?: string | undefined;
    data?: RoomType | undefined;
    code?: ApiCode;
    errors?: ValidationError[] | undefined;

    constructor(data?: IApiResultOfRoomType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            this.message = _data["message"];
            this.data = _data["data"] ? RoomType.fromJS(_data["data"]) : <any>undefined;
            this.code = _data["code"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ValidationError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiResultOfRoomType {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfRoomType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["code"] = this.code;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApiResultOfRoomType {
    isError?: boolean;
    message?: string | undefined;
    data?: RoomType | undefined;
    code?: ApiCode;
    errors?: ValidationError[] | undefined;
}

export class UtilityViewModel implements IUtilityViewModel {
    id?: number;
    nameUtilities?: string | undefined;
    icon?: string | undefined;
    utilitiesType?: number | undefined;
    status?: number;

    constructor(data?: IUtilityViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameUtilities = _data["nameUtilities"];
            this.icon = _data["icon"];
            this.utilitiesType = _data["utilitiesType"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UtilityViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UtilityViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameUtilities"] = this.nameUtilities;
        data["icon"] = this.icon;
        data["utilitiesType"] = this.utilitiesType;
        data["status"] = this.status;
        return data;
    }
}

export interface IUtilityViewModel {
    id?: number;
    nameUtilities?: string | undefined;
    icon?: string | undefined;
    utilitiesType?: number | undefined;
    status?: number;
}

export class ApiResultOfPagedListOfUtility implements IApiResultOfPagedListOfUtility {
    isError?: boolean;
    message?: string | undefined;
    data?: PagedListOfUtility | undefined;
    code?: ApiCode;
    errors?: ValidationError[] | undefined;

    constructor(data?: IApiResultOfPagedListOfUtility) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            this.message = _data["message"];
            this.data = _data["data"] ? PagedListOfUtility.fromJS(_data["data"]) : <any>undefined;
            this.code = _data["code"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ValidationError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiResultOfPagedListOfUtility {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfPagedListOfUtility();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["code"] = this.code;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApiResultOfPagedListOfUtility {
    isError?: boolean;
    message?: string | undefined;
    data?: PagedListOfUtility | undefined;
    code?: ApiCode;
    errors?: ValidationError[] | undefined;
}

export class PagedListOfUtility implements IPagedListOfUtility {
    pageIndex?: number;
    pageSize?: number;
    rowModify?: number;
    totalCount?: number;
    totalPages?: number;
    items?: Utility[] | undefined;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedListOfUtility) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageIndex = _data["pageIndex"];
            this.pageSize = _data["pageSize"];
            this.rowModify = _data["rowModify"];
            this.totalCount = _data["totalCount"];
            this.totalPages = _data["totalPages"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Utility.fromJS(item));
            }
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedListOfUtility {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListOfUtility();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageIndex"] = this.pageIndex;
        data["pageSize"] = this.pageSize;
        data["rowModify"] = this.rowModify;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedListOfUtility {
    pageIndex?: number;
    pageSize?: number;
    rowModify?: number;
    totalCount?: number;
    totalPages?: number;
    items?: Utility[] | undefined;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class UtilityRequest extends PagingRequest implements IUtilityRequest {
    utilitiesType?: number | undefined;

    constructor(data?: IUtilityRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.utilitiesType = _data["utilitiesType"];
        }
    }

    static override fromJS(data: any): UtilityRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UtilityRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["utilitiesType"] = this.utilitiesType;
        super.toJSON(data);
        return data;
    }
}

export interface IUtilityRequest extends IPagingRequest {
    utilitiesType?: number | undefined;
}

export class ApiResultOfUtility implements IApiResultOfUtility {
    isError?: boolean;
    message?: string | undefined;
    data?: Utility | undefined;
    code?: ApiCode;
    errors?: ValidationError[] | undefined;

    constructor(data?: IApiResultOfUtility) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isError = _data["isError"];
            this.message = _data["message"];
            this.data = _data["data"] ? Utility.fromJS(_data["data"]) : <any>undefined;
            this.code = _data["code"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ValidationError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiResultOfUtility {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResultOfUtility();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isError"] = this.isError;
        data["message"] = this.message;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["code"] = this.code;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IApiResultOfUtility {
    isError?: boolean;
    message?: string | undefined;
    data?: Utility | undefined;
    code?: ApiCode;
    errors?: ValidationError[] | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}